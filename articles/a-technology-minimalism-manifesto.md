# A Technology Minimalism Manifesto
Clifford Carnmo, December 2024

>“An idiot admires complexity, a genius admires simplicity” -- Terry Davis

## General assumptions
* Fewer moving parts means fewer unexpected behaviors.
* A lower amount of noise, clutter, installed software, and applications means a reduced probability of failure.
* Minimal input, maximum output.

## Hardware
* Choose one or two hardware vendors for your desktops and laptops and stick with them until you have learned their quirks.
* Familiarize yourself with the hardware components of your system.
* When possible, choose hardware components that provide open-source drivers.
* Use wired peripherals such as keyboards, mice, and headphones.
* Disable all redundant LEDs on your devices.
* Use solid-state storage devices and enable fstrim.
* Repurpose old systems to get a new life as, for example, a media center, lab node, or NAS.
* Use the least amount of hardware components needed.
* Building your own computer is fun and gives you greater control over many aspects of its configuration and function.
* Keep a multitool, external hard drive, and recovery media, such as a bootable operating/rescue system, on a USB drive in your bag or backpack.

## Operating System
* Do not use Microsoft Windows or Apple macOS.
* Use a GNU/Linux distribution or a UNIX-like operating system.
* Keep your operating system minimal, lean, and fast.
* Learn how your operating system works and how to interact with it programmatically.
* Activate only the services and background processes needed for your workflow.
* Minimize operating system distractions and reduce all unwanted calls for your attention to zero.
* Use a terminal to do most of your work.
* Routinely perform system administration tasks and housekeeping.

## Programs and Tools
* Use your distribution's package manager to install, remove, and upgrade software.
* Avoid Snap, Flatpak, and AppImages if you can. Your package manager knows what it's doing.
* Choose a terminal emulator, shell, and text editor and stick with them unconditionally until they are stuck with you and your muscle memory.
* Build your own tools and scripts to fit your workflow and solve common tasks.
* Clean up after finishing a project or session. Remove downloaded files that are no longer needed.
* Use portable and open-source formats for your data.

## Information Security
* Use a firewall with a limited amount of open ports to fulfill your needs.
* Drop all incoming ping requests.
* Do not use standard ports for common network services like FTP and SSH.
* Use a VPN.
* Do not under any circumstance use a cloud-based password manager. Instead, use a local password manager such as KeePass.
* Backup your password database regularly.
* Use a 2FA/TOTP solution that does not require you to first authenticate with Big Tech.
* Disable password authentication and use SSH key pairs to authenticate to remote systems.
* Disable the root account on all your devices and use sudo when needed.
* Use a hardware authentication device such as YubiKey, Thetis or NitroKey.

## Information Management
* Do not use social media. There is nothing social about them.
* Practice healthy skepticism and gather information from different perspectives and sources.
* Disable every single notification and visual, auditory, or tactile distraction on all your devices.
* Implement a routine where you check your notifications, messages, and e-mails during times that suit you.
* Turn off or put your phone in do not disturb mode when you go to sleep.
* Generally, the internet is broken. Always use a content-filtering browser extension such as uBlock Origin Lite to block ads, popups, and other unwanted distractions.

## Software Development
* Learn low-level programming first, then learn high-level.
* Do not blindly rely on an IDE. Get comfortable writing code in a simple text editor without auto-complete and AI features.
* Develop software that requires as few external dependencies as possible.
* Develop software that does one thing well.
* Develop software that can operate on input from another program's output.
* Develop software with as little redundant functionality as possible.
* Always prefer simple and elegant solutions over complex and cryptic.
* Do not try to be smarter than a compiler.
* Do not overengineer to show off. Simplicity and humility go well together.
* Implement logging in a non-binary format.
* Document how you think, not explanations of your code.
* Use the right tools for the job.
* Be opinionated about software design and architecture but always acknowledge and consider alternatives.
* Always prefer static, type-safe, and compiled programming languages.
* When considering dynamic, interpreted, garbage-collected/automatic memory-managed languages and frameworks, always prefer mature and established industry standards.
* Do not fall for trends or hype.

## Contribute and Give Back
* Use your skills and devote some of your spare time to help software projects that you find useful and use on a regular basis.
* Help your friends.
* Share your knowledge and experience with others.
* Donate to organizations and communities that provide software and services that are useful to you.

## Hone Your Skills and Improve Your Tools
* Keep updated on hardware and software related to the fields you specialize in.
* Work on both serious projects and silly gadgets.
* Keep a log and document new knowledge and insights.
* Invite others to collaborate and give constructive feedback on your work.
* Organize your files when you have some downtime.
* Routinely physically clean your devices with suitable cleaning agents and microfiber cloth.
* Routinely physically clean your desk or similar place where you do most of your work.
* Configure and reconfigure settings to suit your current needs.
* Evaluate new options to replace your existing tools.
* Reduce your dependency on Big Tech and corporations.
* Read books.
